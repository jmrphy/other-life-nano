---

type MarkdownHeading = {
  depth: number;
  slug: string;
  text: string;
};

interface Props {
  headings: MarkdownHeading[];
  variant?: 'desktop' | 'mobile';
  class?: string;
}

const { headings, variant = 'desktop', class: className = '' } = Astro.props;

const toc = headings.filter(heading => heading.depth > 1 && heading.depth < 4);

// Generate consistent classes based on theme and variant
const getVariantClasses = () => {
  if (variant === 'mobile') {
    return {
      nav: 'toc-mobile block xl:hidden',
      container: 'bg-white dark:bg-stone-800 border border-stone-200 dark:border-stone-700 rounded-lg shadow-lg p-4 mb-8',
      title: 'text-stone-900 dark:text-white font-semibold text-sm mb-3 pb-2 border-b border-stone-200 dark:border-stone-700',
      list: 'space-y-2',
      item: 'block',
      link: 'block text-xs text-stone-700 dark:text-stone-300 hover:text-stone-900 dark:hover:text-white py-2 px-2 rounded transition-colors duration-200 hover:bg-stone-50 dark:hover:bg-stone-700 leading-relaxed',
      activeLink: 'font-medium text-stone-900 dark:text-white bg-stone-100 dark:bg-stone-700'
    };
  }
  
  return {
    nav: 'toc-desktop hidden xl:block',
    container: 'sticky top-0 max-h-[calc(100vh-10rem)] overflow-y-auto',
    title: 'text-white font-semibold text-xs mb-4 pb-2 border-b border-white/20 tracking-wide uppercase',
    list: 'space-y-2',
    item: 'block',
    link: 'block text-xs text-white/80 hover:text-white py-1.5 px-0 transition-colors duration-200 leading-relaxed',
    activeLink: 'font-medium text-white'
  };
};

const classes = getVariantClasses();
---

{toc.length > 0 && (
  <nav class={`${classes.nav} ${className}`} aria-label="Table of Contents">
    <div class={classes.container}>
      <h2 class={classes.title}>Table of Contents</h2>
      <ul class={classes.list} role="list">
        {toc.map(heading => {
          const isH3 = heading.depth === 3;
          const itemClasses = isH3 ? 'ml-4' : '';
          const linkClasses = isH3 
            ? classes.link.replace('text-xs', 'text-[10px]')
            : classes.link;
          
          return (
            <li class={`${classes.item} ${itemClasses}`}>
              <a 
                href={`#${heading.slug}`} 
                class={linkClasses}
                data-toc-link
                data-heading-id={heading.slug}
                title={heading.text}
              >
                <span class="block">{heading.text}</span>
              </a>
            </li>
          );
        })}
      </ul>
    </div>
  </nav>
)}

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = document.querySelectorAll('[data-toc-link]');
    const headings = Array.from(document.querySelectorAll('article h2[id], article h3[id]'));

    if (!tocLinks.length || !headings.length) {
      return;
    }

    // Helper function to get active link classes based on variant
    const getActiveClasses = (link: Element) => {
      const isMobile = link.closest('.toc-mobile');
      if (isMobile) {
        return ['font-medium', 'text-stone-900', 'dark:text-white', 'bg-stone-100', 'dark:bg-stone-700'];
      }
      return ['font-medium', 'text-white'];
    };

    // Helper function to remove active classes
    const removeActiveClasses = (link: Element) => {
      const classes = ['font-medium', 'text-stone-900', 'dark:text-white', 'bg-stone-100', 'bg-stone-50', 'dark:bg-stone-700', 'border-l-2', 'border-stone-400', 'dark:border-stone-500', 'text-white'];
      link.classList.remove(...classes);
    };

    // Enhanced intersection observer with better threshold and margins
    const observer = new IntersectionObserver(entries => {
      let activeHeading: Element | null = null;
      let maxIntersectionRatio = 0;

      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio > maxIntersectionRatio) {
          maxIntersectionRatio = entry.intersectionRatio;
          activeHeading = entry.target;
        }
      });

      if (activeHeading) {
        const id = (activeHeading as Element).getAttribute('id');
        if (id) {
          const correspondingLinks = document.querySelectorAll(`[data-heading-id="${id}"]`);
          
          // Remove active state from all links
          tocLinks.forEach(link => removeActiveClasses(link));
          
          // Add active state to corresponding links (both desktop and mobile)
          correspondingLinks.forEach(link => {
            const activeClasses = getActiveClasses(link);
            link.classList.add(...activeClasses);
          });
        }
      }
    }, {
      rootMargin: '-10% 0% -70% 0%',
      threshold: [0, 0.25, 0.5, 0.75, 1]
    });

    // Observe all headings
    headings.forEach(heading => {
      observer.observe(heading);
    });

    // Smooth scroll behavior for TOC links
    tocLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = link.getAttribute('data-heading-id');
        if (targetId) {
          const targetElement = document.getElementById(targetId);
          
          if (targetElement) {
            const yOffset = -80; // Account for header height
            const y = targetElement.getBoundingClientRect().top + window.pageYOffset + yOffset;
            
            window.scrollTo({
              top: y,
              behavior: 'smooth'
            });
            
            // Update URL without triggering scroll
            history.pushState({}, '', `#${targetId}`);
          }
        }
      });
    });

    // Initialize first heading as active if no hash in URL
    if (!window.location.hash && tocLinks.length > 0 && headings.length > 0) {
      const firstHeadingId = headings[0]?.id;
      if (firstHeadingId) {
        const firstLinks = document.querySelectorAll(`[data-heading-id="${firstHeadingId}"]`);
        firstLinks.forEach(link => {
          const activeClasses = getActiveClasses(link);
          link.classList.add(...activeClasses);
        });
      }
    }

    // Handle direct navigation to hash
    if (window.location.hash) {
      const targetId = window.location.hash.substring(1);
      const targetLinks = document.querySelectorAll(`[data-heading-id="${targetId}"]`);
      targetLinks.forEach(link => {
        const activeClasses = getActiveClasses(link);
        link.classList.add(...activeClasses);
      });
    }
  });
</script> 